## Installation

Building the source for the CAN translator for the chipKIT microcontroller
requires [MPIDE][] (the development environment and compiler toolchain for
chipKIT provided by Digilent). Installing MPIDE can be a bit quirky on some
platforms, so if you're having trouble take a look at the [installation guide
for MPIDE](http://chipkit.org/wiki/index.php?title=MPIDE_Installation).

Some of the library dependencies are included in this repository as git
submodules, so before you go further run:

    $ git submodule init && git submodule update

If this doesn't print out anything or gives you an error, make sure you cloned
this repository from GitHub with git and that you didn't download a zip file.
The zip file is missing all of the git metadata, so submodules will not work.

It also requires some libraries from Microchip that we are unfortunately unable
to include or link to as a submodule from the source because of licensing
issues:

* Microchip USB device library (download DSD-0000318 from
    the bottom of the [Network Shield page][])
* Microchip CAN library (included in the same DSD-0000318 package as the USB
  device library)

Download the zip file that contains these two libraries and extract the folders
into the `libs` directory in this project. It should look like this:

    - /Users/me/projects/cantranslator/
    ---- libs/
    -------- chipKITUSBDevice/
             chipKitCAN/
            ... other libraries

If you're using Mac OS X or Windows, make sure to install the FTDI driver that
comes with the MPIDE download. The chipKIT uses a different FTDI chip, so even
if you've used the Arduino before, you still need to install this driver.

[MPIDE]: https://github.com/chipKIT32/chipKIT32-MAX/downloads
[Max32 page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,895&Prod=CHIPKIT-MAX32
[Network Shield page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,943&Prod=CHIPKIT-NETWORK-SHIELD

Although we just installed MPIDE, building via the GUI is **not supported**. We
use GNU Make to compile and upload code to the device. You still need to
download and extract the MPIDE someplace, as it contains the PIC32 compilation
toolchain.

You need to set an environment variable (e.g. in your `.bashrc`) to let the
project know where you installed MPIDE (make sure to change these defaults if
your system is different!):

    # Path to the extracted MPIDE folder (this is correct for OS X)
    export MPIDE_DIR=/Applications/Mpide.app/Contents/Resources/Java

Remember that if you use `export`, the environment variables are only set in the
terminal that you run the commands. If you want them active in all terminals
(and you probably do), you need to add these `export ...` lines to the file
`~/.bashrc` (in Linux) or `~/.bash_profile` (in OS X) and start a new terminal.

Once this is set up, `cd` into the `src` subdirectory, build and
upload to the device.

    $ git submodule init && git submodule update
    $ make clean
    $ make
    $ make flash

If the flash command can't find your chipKIT, you may need to set the
`ARDUINO_PORT` variable (if the serial emulator doesn't show up as `/dev/ttyUSB*`
(in Linux) or `/dev/tty.usbserial*` (in Mac OS X)).

**Troubleshooting**

If the compilation didn't work:

* Make sure the submodules are up to date - run `git submodule update --init`
  and then `git status` and make sure there are no modified files in the working
  directory.
* Did you download the .zip file of the `cantranslator` project from GitHub? Try
  using git to clone the repository instead - the library dependencies are
  stored as git submodules and do not work when using the zip file.

### LPC17xx

Support for the NXP LPC17xx, an ARM Cortex M3 microcontroller, is experimental
at the moment and the documentation is incomplete. We are building successfully
on the NGX Blueboard 1768-H using the Olimex ARM-OCD-USB JTAG programmer.

### Ubuntu

### Arch Linux

    $ pacman -S openocd

Download and install from the AUR:

* gcc-arm-none-eabi

### OS X

Install Homebrew. Then:

    $ brew install libftdi libusb
    $ brew tap PX4/homebrew-px4
    $ brew install gcc-arm-none-eabi

Wait a looooong time.

Download the OpenOCD source distribution and build manually:

    $ ./configure --enable-ft2232_libftdi
    $ make
    $ sudo make install

Edit `/System/Library/Extensions/FTDIUSBSerialDriver.kext/Contents/Info.plist`
and remove the Olimex sections, then reload the module:

    $ sudo kextunload /System/Library/Extensions/FTDIUSBSerialDriver.kext/
    $ sudo kextload /System/Library/Extensions/FTDIUSBSerialDriver.kext/

### Compiling

Once the dependencies are installed, attach a JTAG adapter to your computer and
the CAN translator, then compile and flash an LPC1768 Blueboard like so:

    $ make clean
    $ PLATFORM=LPC17XX make -j4
    $ PLATFORM=LPC17XX make flash

The config files in this repository assume your JTAG adapter is the Olimex
ARM-USB-OCD unit. If you have a different unit, change the first line in
`conf/flash.cfg` to the correct value.

## Compiling and Uploading

Once the libraries are installed and you run `make`, you'll notice that it won't
compile - you'll get a bunch of errors that look like this:

```
build-cli/canutil_chipkit.o: In function `initializeCan(CanBus*)':
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xb8): undefined reference to `initializeFilterMasks(unsigned long long, int*)'
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xcc): undefined reference to `initializeFilters(unsigned long long, int*)'
build-cli/cantranslator.o: In function `receiveWriteRequest(char*)':
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x40): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x48): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x7c): undefined reference to `getCommands()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x84): undefined reference to `getCommandCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xa4): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xac): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x118): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x120): undefined reference to `getSignalCount()'
build-cli/cantranslator.o: In function `initializeAllCan()':
cantranslator.cpp:(.text._Z16initializeAllCanv+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text._Z16initializeAllCanv+0x30): undefined reference to `getCanBusCount()'
build-cli/cantranslator.o: In function `_ZL17customUSBCallback9USB_EVENTPvj.clone.0':
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x70): undefined reference to `getMessageSet()'
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x98): undefined reference to `getMessageSet()'
build-cli/cantranslator.o: In function `receiveCan(CanBus*)':
cantranslator.cpp:(.text._Z10receiveCanP6CanBus+0x40): undefined reference to `decodeCanMessage(int, unsigned char*)'
build-cli/cantranslator.o: In function `loop':
cantranslator.cpp:(.text.loop+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text.loop+0x30): undefined reference to `getCanBusCount()'
collect2: ld returned 1 exit status
make[1]: *** [build-cli/cantranslator.elf] Error 1
make[1]: Leaving directory `/home/peplin/dev/ford/cantranslator/cantranslator'
make: *** [all] Error 2
```

The open source repository is missing the definition of a `decodeCanMessage`
function (and a few others functions declared in `signals.h`). These are the
parts you must implement yourself if have details about your vehicle's message
formats, or by following the input specification designed here, have
auto-generated.

You have three options: implementing these functions manually for your specific
vehicle, using the code auto-generation scripts or using a pre-built binary.

### Manual

You must implement the functions defined in the `signals.h` header file. The
documentation of those functions describes the expected effect of each.
Implement these in a file called `signals.cpp` and the code should now compile.

You must know the CAN message formats of the vehicle you want to use with the
CAN translator, as you cannot implement these functions without that knowledge.

### Auto-generation

The code auto-generation script accepts a [JSON input file][input-specs] that
defines the CAN messages and signals of interest and rewrites it as C data
structures, ready to be downloaded to the device. Check the "Input
Specification" section for the details of the input format. You must know the
CAN message formats of the vehicle you want to use with the CAN translator, as
you cannot create these input files without that knowledge.

Once you have one or more input JSON files, run the `generate_source.py` script
to create a file that defines `decodeCanMessage`:

    ./generate_code.py --json signals.json > signals.cpp

Drop the new `signals.cpp` file in the `src` folder, and it should now compile.
Don't add anything else to this file - it's derivative of the master JSON, and
should be able to be wiped and recreated at any time.

If you have multiple CAN buses and want to define their signals and messages in
separate files, just pass multiple JSON files:

    ./generate_code.py --json highspeed.json --json mediumspeed.json > signals.cpp

Note that the JSON files are parsed and merged, so if you want to define custom
handlers and states separately from the signal definition itself, you can store
them in separate files and they will be merged on import.

## IDE Support

It is possible to use an IDE like Eclipse to edit and compile the project.

* Follow the directions in the above "Installation" section.
* Install Eclipse with the [CDT project](http://www.eclipse.org/cdt/)
* In Eclipse, go to `File -> Import -> C/C++ -> Existing Code as Makefile Project`
  and then select the `cantranslator/src` folder.
* In the project's properties, under `C/C++ General -> Paths and Symbols`, add
  these to the include paths for C and C++:
    * `${MPIDE_DIR}/hardware/pic32/compiler/pic32-tools/pic32mx/include`
    * `${MPIDE_DIR}/hardware/pic32/cores/pic32`
    * `/cantranslator/libs/CDL/LPC17xxLib/inc` (add as a "workspace path")
    * `/cantranslator/libs/chipKITCAN` (add as a "workspace path")
    * `/cantranslator/libs/chipKITUSBDevice` (add as a "workspace path")
    * `/cantranslator/libs/chipKITUSBDevice/utility` (add as a "workspace path")
    * `/cantranslator/libs/chipKITEthernet` (add as a "workspace path")
    * `/usr/include` (only if you want to use the test suite, which requires the
      `check` C library)
* In the same section under Symbols, if you are building for the chipKIT define
  a symbol with the name `__PIC32__`
* In the project folder listing, select `Resource Configurations -> Exclude from
  Build` for these folders:
    * `libs`
    * `build`

If you didn't set up the environment variables from the `Installation` section
(e.g. `MPIDE_HOME`), you can also do that from within Eclipse in `C/C++` project
settings.

There will still be some errors in the Eclipse problem detection, e.g. it
doesn't seem to pick up on the GCC `__builtin_*` functions, and some of the
chipKIT libraries are finicky. This won't have an effect on the actual build
process, just the error reporting.

## Test Suite

The non-chipKIT code in this repository includes a small test suite that uses
the [check][] library. After installing that library, run the test suite like
so:

    cantranslator/ $ make test

The [check][] library can be installed in Ubuntu Linux quite easily:

    $ sudo apt-get install check

and in Mac OS X, it's available through [homebrew][]:

    $ brew install check

[check]: http://check.sourceforge.net
[homebrew]: http://mxcl.github.com/homebrew/

## Emulator

The repository includes a rudimentary CAN bus emulator. Use the `EMULATOR` flag
to build this:

    $ make clean
    $ EMULATOR=1 make -j4

The emulator generates fakes values for many OpenXC signals and sends them over
USB as if it were plugged into a live CAN bus.

## USB Device Driver

For details on the USB device, particularly useful if you are trying to connect
to it from a new programming language or environment, see the [USB
readme](https://github.com/openxc/cantranslator/blob/master/README_usb.mkd).

## Serial Output

You can optionally receive the output data over a serial connection in
addition to USB. The same JSON messages are also sent over UART on
pins 18 and 19 of the chipKIT Max32 at a baud rate of 115200. On LPC17XX boards
like the Blueboard, the baud rate is 921600 and requires that the CTS1 and RTS1
pins are also connected to enabled hardware flow control.

In the same way that you can send OpenXC writes over USB using the OUT direction
of the USB endpoint, you can send identically formatted messages in the opposite
direction on the serial device - from the host to the CAN translator. They'll be
processed in exactly the same way. These write messages are accepted via serial
even if USB is connected.

[input-specs]: https://github.com/openxc/cantranslator/blob/master/README_mappings.mkd
