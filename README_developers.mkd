## Installation

Building the source for the CAN translator for the chipKIT microcontroller
requires [MPIDE][] (the development environment and compiler toolchain for
chipKIT provided by Digilent). Installing MPIDE can be a bit quirky on some
platforms, so if you're having trouble take a look at the [installation guide
for MPIDE](http://chipkit.org/wiki/index.php?title=MPIDE_Installation).

Some of the library dependencies are included in this repository as git
submodules, so before you go further run:

    $ git submodule init
    $ git submodule update

It also requires some libraries from Microchip that we are unfortunately unable
to include or link to as a submodule from the source because of licensing
issues:

* Microchip USB device library (download DSD-0000318 from
    the bottom of the [Network Shield page][])
* Microchip CAN library (included in the same DSD-0000318 package as the USB
  device library)

Download the zip file that contains these two libraries and extract the folders
into the `libs` directory in this project. It should look like this:

    - /Users/me/projects/cantranslator/
    ---- libs/
    -------- chipKITUSBDevice/
             chipKitCAN/
            ... other libraries

If you're using Mac OS X or Windows, make sure to install the FTDI driver that
comes with the MPIDE download. The chipKIT uses a different FTDI chip, so even
if you've used the Arduino before, you still need to install this driver.

[MPIDE]: https://github.com/chipKIT32/chipKIT32-MAX/downloads
[Max32 page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,895&Prod=CHIPKIT-MAX32
[Network Shield page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,943&Prod=CHIPKIT-NETWORK-SHIELD

Although we just installed MPIDE, building via the GUI is **not supported**. We
use GNU Make to compile and upload code to the device. You still need to
download and extract the MPIDE someplace, as it contains the PIC32 compilation
toolchain.

You need to set an environment variable (e.g. in your `.bashrc`) to let the
project know where you installed MPIDE (make sure to change these defaults if
your system is different!):

    # Path to the extracted MPIDE folder (this is correct for OS X)
    export MPIDE_DIR=/Applications/Mpide.app/Contents/Resources/Java

Remember that if you use `export`, the environment variables are only set in the
terminal that you run the commands. If you want them active in all terminals
(and you probably do), you need to add these `export ...` lines to the file
`~/.bashrc` (in Linux) or `~/.bash_profile` (in OS X) and start a new terminal.

Once this is set up, `cd` into the `src` subdirectory, build and
upload to the device:

    $ make clean
    $ make
    $ make flash

If the flash command can't find your chipKIT, you may need to set the
`ARDUINO_PORT` variable (if the serial emulator doesn't show up as `/dev/ttyUSB*`
(in Linux) or `/dev/tty.usbserial*` (in Mac OS X)).

### LPC17xx

Support for the NXP LPC17xx, an ARM Cortex M3 microcontroller, is experimental
at the moment and the documentation is incomplete. We are building successfully
on the NGX Blueboard 1768-H using the Olimex ARM-OCD-USB JTAG programmer.

### Ubuntu

### Arch Linux

    $ pacman -S openocd

Download and install from the AUR:

* gcc-arm-none-eabi

### OS X

Install Homebrew. Then:

    $ brew install libftdi libusb
    $ brew tap PX4/homebrew-px4
    $ brew install gcc-arm-none-eabi

Wait a looooong time.

Download the OpenOCD source distribution and build manually:

    $ ./configure --enable-ft2232_libftdi
    $ make
    $ sudo make install

Edit `/System/Library/Extensions/FTDIUSBSerialDriver.kext/Contents/Info.plist`
and remove the Olimex sections, then reload the module:

    $ sudo kextunload /System/Library/Extensions/FTDIUSBSerialDriver.kext/
    $ sudo kextload /System/Library/Extensions/FTDIUSBSerialDriver.kext/

### Compiling

Once the dependencies are installed, compile and flash an LPC17xx like so:

    $ make clean
    $ BOARD=LPC17xx make -j4
    $ BOARD=LPC17xx make flash

## Compiling and Uploading

Once the libraries are installed and you run `make`, you'll notice that it won't
compile - you'll get a bunch of errors that look like this:

```
build-cli/canutil_chipkit.o: In function `initializeCan(CanBus*)':
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xb8): undefined reference to `initializeFilterMasks(unsigned long long, int*)'
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xcc): undefined reference to `initializeFilters(unsigned long long, int*)'
build-cli/cantranslator.o: In function `receiveWriteRequest(char*)':
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x40): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x48): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x7c): undefined reference to `getCommands()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x84): undefined reference to `getCommandCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xa4): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xac): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x118): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x120): undefined reference to `getSignalCount()'
build-cli/cantranslator.o: In function `initializeAllCan()':
cantranslator.cpp:(.text._Z16initializeAllCanv+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text._Z16initializeAllCanv+0x30): undefined reference to `getCanBusCount()'
build-cli/cantranslator.o: In function `_ZL17customUSBCallback9USB_EVENTPvj.clone.0':
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x70): undefined reference to `getMessageSet()'
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x98): undefined reference to `getMessageSet()'
build-cli/cantranslator.o: In function `receiveCan(CanBus*)':
cantranslator.cpp:(.text._Z10receiveCanP6CanBus+0x40): undefined reference to `decodeCanMessage(int, unsigned char*)'
build-cli/cantranslator.o: In function `loop':
cantranslator.cpp:(.text.loop+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text.loop+0x30): undefined reference to `getCanBusCount()'
collect2: ld returned 1 exit status
make[1]: *** [build-cli/cantranslator.elf] Error 1
make[1]: Leaving directory `/home/peplin/dev/ford/cantranslator/cantranslator'
make: *** [all] Error 2
```

The open source repository is missing the definition of a `decodeCanMessage`
function (and a few others functions declared in `signals.h`). These are the
parts you must implement yourself if have details about your vehicle's message
formats, or by following the input specification designed here, have
auto-generated.

You have three options: implementing these functions manually for your specific
vehicle, using the code auto-generation scripts or using a pre-built binary.

### Manual

You must implement the functions defined in the `signals.h` header file. The
documentation of those functions describes the expected effect of each.
Implement these in a file called `signals.cpp` and the code should now compile.

You must know the CAN message formats of the vehicle you want to use with the
CAN translator, as you cannot implement these functions without that knowledge.

### Auto-generation

The code auto-generation script accepts a [JSON input file][input-specs] that
defines the CAN messages and signals of interest and rewrites it as C data
structures, ready to be downloaded to the device. Check the "Input
Specification" section for the details of the input format. You must know the
CAN message formats of the vehicle you want to use with the CAN translator, as
you cannot create these input files without that knowledge.

Once you have one or more input JSON files, run the `generate_source.py` script
to create a file that defines `decodeCanMessage`:

    ./generate_code.py --json signals.json > signals.cpp

Drop the new `signals.cpp` file in the `cantranslator` sketch folder, and it
should now compile. Don't add anything else to this file - it's derivative of
the master JSON, and should be able to be wiped and recreated at any time.

If you have multiple CAN buses and want to define their signals and messages in
separate files, just pass multiple JSON files:

    ./generate_code.py --json highspeed.json --json mediumspeed.json > signals.cpp

Note that the JSON files are parsed and merged, so if you want to define custom
handlers and states separately from the signal definition itself, you can store
them in separate files and they will be merged on import.

## Test Suite

The non-chipKIT code in this repository includes a small test suite that uses
the [check][] library. After installing that library, run the test suite like
so:

    cantranslator/ $ make test

The [check][] library can be installed in Ubuntu Linux quite easily:

    $ sudo apt-get install check

and in Mac OS X, it's available through [homebrew][]:

    $ brew install check

[check]: http://check.sourceforge.net
[homebrew]: http://mxcl.github.com/homebrew/

## Emulator

The repository includes a rudimentary CAN bus emulator. Use the `EMULATOR` flag
to build this:

    $ make clean
    $ EMULATOR=1 make -j4

The emulator generates fakes values for many OpenXC signals and sends them over
USB as if it were plugged into a live CAN bus.

## USB Device Driver

For details on the USB device, particularly useful if you are trying to connect
to it from a new programming language or environment, see the [USB
readme](https://github.com/openxc/cantranslator/blob/master/README_usb.mkd).

## Serial Output

You can optionally receive the output data over a serial connection in
addition to USB. The messages are automatically sent over a UART connection on
pins 18 and 19 of the chipKIT Max32 at a baud rate of 115200 when not being sent
over USB. To be absolutely clear, OpenXC messages are only sent over serial if
an active USB connection is **not** already receiving the messages.

In the same way that you can send OpenXC writes over USB using the OUT direction
of the USB endpoint, you can send identically formatted messages in the opposite
direction on the serial device - from the host to the CAN translator. They'll be
processed in exactly the same way. These write messages are accepted via serial
even if USB is connected.

[input-specs]: https://github.com/openxc/cantranslator/blob/master/README_mappings.mkd
